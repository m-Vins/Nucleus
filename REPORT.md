# Nucleus Forensics Project

Students:

- Vincenzo Mezzela ( [mezzela@eurecom.fr](mailto:mezzela@eurecom.fr) )
- Ilaria Pilo ( [pilo@eurecom.fr](mailto:pilo@eurecom.fr) )

## Description

The Nucleos project for the Forensics course aims to enhance and revitalize an existing tool called Nucleus, available at [https://bitbucket.org/vusec/nucleus/src/master/](https://bitbucket.org/vusec/nucleus/src/master/). Nucleus is primarily designed to locate function headers in stripped binaries, aiding in the analysis of binary files. However, due to changes in library APIs, the tool was no longer functioning as intended.

The outperformed tasks can be categorized into the following areas of improvement:

1. [**Reorganization of the directory tree**](#reorganization-of-the-directory-tree):
   The initial task involves cloning the Nucleus repository and enhance the directory structure with respect to the basic version proposed [initially](https://bitbucket.org/vusec/nucleus/src/master/) which is pretty basic. This improves code maintainability, readability, and collaboration.
   <!-- TODO migliorare qui -->

2. [**Fixing the Tool**](#fixing-the-tool):
   Addressing the issues that prevent it from functioning correctly. By understanding the changes in library APIs and making the necessary modifications to the codebase in order to restore the tool's functionality.

3. [**Raw files support**](#raw-files-support):
   The tool currently focuses on Portable Executable (PE) and Executable and Linkable Format (ELF) binaries. However, there is still room for improvement in supporting raw binary files.

4. [**Evaluating different architectures performance**](#evaluating-different-architectures-performance):
   While Nucleos has undergone extensive testing for x86 architecture, the effectiveness of its approach on other architectures remains uncertain. For this task, a large number of binaries (~3000) belonging to different architectures along with their ground truth have been exploited to evaluate the performance of the tool. An other ground truth as been built using the `readelf` tool to carry out further testing.

## Artifacts

### Makefile commands

- `make` : build nucleus
- `build_simple_test` : build the programs in the folder `./test/simple_tests`
- `simple_test` : execute `cmp_symbols.sh` on the simple_test binaries
- `test` : run `./utilities/test.sh` on the binaries in `./test/binaries`
- `generate_raw_files` : generate a dataset of raw files starting from the binaries in `./test/binaries`
- `test_raw` : run `./utilities/test_raw.s` over the raw files generated by `generate_raw_files`
- `download_all` : download ~3000 binaries in `./test/binaries` (**WARNING**: it takes time and space on the disk)
- `clean` : remove the intermediate object files, the nucleus binary and the simple_test binaries. It does not touch the binaries in `./test/binaries`

## Reorganization of the directory tree

- [src](./src/): This directory contains the source code files of the project.
- [include](./include): Header files reside in this directory.
- [obj](./obj): This directory is used to store object files generated during the compilation process.
- [test](./test): It contains all the files used for testing (binaries, ground_truth, ...), for further information refer [here](./test/README.md).
- [utilities](./utilities/): It contains a set of scripts used for different purposes, for further information refer [here](./utilities/README.md).

## Fixing the tool

The [source code](https://bitbucket.org/vusec/nucleus/src/master/) was broken due to change in the API of the library `Binary File Descriptor`.

### Issue 1

The function `bfd_octets_per_byte` is now different and it need to know the section of the binary whose we want to retrieve the number of octets per byte, this we wrote a function to retrieve the section given the virtual memory address:

```c
asection *get_section_by_vma(const bfd *bfd_h, const uint64_t vma)
{
  for (asection *bfd_sec = bfd_h->sections; bfd_sec->next != bfd_h->section_last->next; bfd_sec = bfd_sec->next)
  {
    if (bfd_sec->vma <= vma && bfd_sec->vma + bfd_sec->size > vma)
      return bfd_sec;
  }

  // section not found!
  return nullptr;
}
```

then to fix the issue:

```diff
- bfd_vma data_offset = bfd_reloc->address * bfd_octets_per_byte(bfd_h);
+asection *bfd_sec = get_section_by_vma(bfd_h, sec.vma);
+if (bfd_sec == NULL)
+{
+   print_err("failed to get section from vma");
+   goto fail;
+}
+bfd_vma data_offset = bfd_reloc->address * bfd_octets_per_byte(bfd_h, bfd_sec);
+bfd_byte *data = sec.bytes + (data_offset - sec.vma);
```

### Issue 2

In [loader.cc](./src/loader.cc) function `load_sections_bfd` doesn't need the first parameter:

```diff
- bfd_flags = bfd_get_section_flags(bfd_h, bfd_sec);
+ bfd_flags = bfd_section_flags(bfd_sec);
```

### Issue 3

In [loader.cc](./src/loader.cc) function `load_sections_bfd` the following functions doesn't need the first parameter:

```diff
- vma = bfd_section_vma(bfd_h, bfd_sec);
- size = bfd_section_size(bfd_h, bfd_sec);
- secname = bfd_section_name(bfd_h, bfd_sec);
+ vma = bfd_section_vma(bfd_sec);
+ size = bfd_section_size(bfd_sec);
+ secname = bfd_section_name(bfd_sec);
```

## Raw files support

The support for raw file was already present in `nucleus`, even though it uses a very simple approach since it just disassemles from the start of the file (or at a given offset chosen by the user).
Our goal was to try to improve this technique to make `nucleus` able to find the best offset to start disassebling the file.

The very first thing we've done was to try to understand how the tool works, especially focusing on the disassemblying phase. To do so, we've instrumented the program in order to log information to see the flow of the program using the format `[DBG..] blablabla` so that grepping on `DBG` show us only the info that we need.
In order to enable the loggin it's just needed to set `DBG` to `1` in [disasm-x86.cc](./src/disasm-x86.cc) and in [disasm.cc](/src/disasm.cc).

<!-- TODO explain a bit how the disassembling works -->

Since the option to start disassembling at a given offset was already present, we tried to see if changing the offset makes `nucleus` to perform better. Using the [script test_offset.py](./utilities/test_offset.py) we collected the number of offsets that succesfully find each function.
The script showed us that changing the offset almost doesn't affect the result of `nucleus` because almost all the functions have been found running `nucleus` at every offset. This suggests us that the disassembling process probably realignes very fast.

<!-- TODO explain better -->

Nevertheless, we added the option `-o` in `nucleus` in order to make it trying to disassemble at a different number of offset and collect information about the number of offset that find each function. Exactly the same ad the previous python script, but now embedded in `nucleus`.

<!-- TODO add a screnshoot of the output -->

## Evaluating different architectures performance

<!-- TODO -->
